<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>trigkit4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="trigkit4">
<meta property="og:url" content="hawx1993.github.io/index.html">
<meta property="og:site_name" content="trigkit4">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="trigkit4">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="trigkit4" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">trigkit4</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/hawx1993" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/hwax1993" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/trigkit4" title="zhihu">zhihu</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/trigkit4" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://segmentfault.com/u/trigkit4/">trigkit4</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">美团网前端实习生，微信：hawx1993</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">trigkit4</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/me.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">trigkit4</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hawx1993" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/hwax1993" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/trigkit4" title="zhihu">zhihu</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/trigkit4" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-github-project" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/18/github-project/" class="article-date">
  	<time datetime="2015-08-18T10:21:22.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/github-project/">github上值得关注的前端项目</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="http://microjs.com/#" target="_blank" rel="external">http://microjs.com/#</a></p>
</blockquote>
<p>该网站的资源都托管到了<code>github</code>，<code>microjs.com</code>是一个可以让你选择微型的<code>js</code>类库的网站，该网站里的<code>js</code>库都是压缩后不大于5KB的，非常实用</p>
<h2 id="综合/资源">综合/资源</h2><ul>
<li><a href="https://github.com/dypsilon/frontend-dev-bookmarks" target="_blank" rel="external">frontend-dev-bookmarks</a> 一个巨大的前端开发资源清单。<code>star:15000</code></li>
</ul>
<ul>
<li><a href="https://github.com/foru17/front-end-collect" target="_blank" rel="external">front-end-collect</a> 分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者。<code>star:860</code></li>
</ul>
<ul>
<li><p><a href="https://github.com/hawx1993/Front-end-Interview-questions" target="_blank" rel="external">Front-end-Interview-questions</a>   史上最全前端开发面试问题及答案</p>
</li>
<li><p><a href="https://github.com/lvwzhen/f2e-hub" target="_blank" rel="external">f2e-hub</a> 包含<code>Animation，UI，dialog，Carousels，color，image，workflow</code>等。<code>star:100</code></p>
</li>
<li><p><a href="https://github.com/sorrycc/awesome-javascript" target="_blank" rel="external">awesome-javascript</a> 一系列很棒的<code>javascript</code> 库，资源。<code>star:3100</code></p>
</li>
</ul>
<ul>
<li><p><a href="https://github.com/JacksonTian/fks" target="_blank" rel="external">fks</a>  前端技能汇总，包含前端知识架构，后端知识，<code>linux</code>，书籍推荐等。<code>star:4000</code></p>
</li>
<li><p><a href="https://github.com/youyudehexie/node123" target="_blank" rel="external">node123</a> <code>node.js</code>中文资料导航。<code>star:1200</code></p>
</li>
<li><p><a href="https://github.com/hoosin/mobile-web-favorites" target="_blank" rel="external">mobile-web-favorites</a> 移动端web开发收藏夹。<code>star:200</code></p>
</li>
<li><p><a href="https://github.com/nimojs/gulp-book" target="_blank" rel="external">gulp-book</a> <code>Gulp</code> 入门指南 </p>
</li>
</ul>
<h2 id="样式/UI/css">样式/UI/css</h2><ul>
<li><a href="https://github.com/Semantic-Org/Semantic-UI" target="_blank" rel="external">Semantic-UI</a> 让你使用任何<code>HTML</code>标签 来表现UI控件。<br>这是一款语义化设计的前端框架，为攻城师而制作的可复用的开源前端框架。<code>star:17500</code></li>
</ul>
<ul>
<li><p><a href="https://github.com/primer/primer" target="_blank" rel="external">primer</a>   <code>CSS</code>风格指南。<code>star:3600</code></p>
</li>
<li><p><a href="https://github.com/jorgebastida/glue#glue" target="_blank" rel="external">glue</a> 一个生成CSS sprites的简单的命令行工具。star:2.5K (7.19更新)</p>
</li>
<li><p><a href="https://github.com/postcss/postcss#plugins" target="_blank" rel="external">postcss</a> 用js插件来对css进行转换，类似Sass的预编译器，但实现了模块化，并且更加强大。<code>star:4.5K</code>(7.31更新)</p>
</li>
<li><p><a href="https://github.com/lojjic/PIE" target="_blank" rel="external">css3 PIE</a> 允许在IE上使用<code>CSS3</code>绝大部分的酷炫功能。官网：<a href="http://css3pie.com/" target="_blank" rel="external">http://css3pie.com/</a></p>
</li>
</ul>
<h2 id="测试/工具">测试/工具</h2><ul>
<li><a href="https://github.com/mochajs/mocha" target="_blank" rel="external">mocha</a> 一个简单、灵活有趣的 <code>JavaScript</code> 测试框架，用于 <code>Node.js</code> 和浏览器上的 <code>JavaScript</code> 应用测试。 <code>star:6680</code></li>
</ul>
<ul>
<li><p><a href="https://github.com/zmoazeni/csscss" target="_blank" rel="external">csscss</a> css代码冗余分析仪，用于分析冗余 。<code>star:2800</code></p>
</li>
<li><p><a href="https://github.com/addyosmani/es6-tools" target="_blank" rel="external">es6-tools</a>  <code>es6</code> 工具集，包括<code>Grunt Tasks，Gulp Plugins，Broccoli Plugins，Brunch Plugins，Webpack plugins</code>等等。<code>star:1860</code></p>
</li>
<li><p><a href="https://github.com/caolan/async" target="_blank" rel="external">async</a> 一个工具模块，提供了直接而强大的 <code>JavaScript</code> 异步功能。虽然是为 <code>Node.js</code> 设计的，但是它也可以直接在浏览器中使用。<code>star:13000</code></p>
</li>
<li><p><a href="https://github.com/mycolorway/simditor" target="_blank" rel="external">simditor</a> 团队协作工具 <code>Tower</code> 使用的富文本编辑器。<code>star:1300</code></p>
</li>
<li><p><a href="https://github.com/yaniswang/HTMLHint" target="_blank" rel="external">HTMLHint</a> <code>HTML</code> 静态代码分析工具，可以集成到<code>IDE</code>环境或编译系统中。<code>star:900</code></p>
</li>
<li><p><a href="https://github.com/jshint/jshint" target="_blank" rel="external">jshint</a> <code>js</code>静态代码分析工具，可以帮你检测<code>js</code>语法错误和潜在的问题。<code>star:5100</code></p>
</li>
<li><p><a href="https://github.com/CSSLint/csslint" target="_blank" rel="external">csslint</a> 分析和优化你的<code>CSS</code>样式表的工具。由<a href="http://www.nczonline.net/" target="_blank" rel="external">Nicholas C.<br>Zakas</a>所写。<code>star:2700</code></p>
</li>
<li><p><a href="https://github.com/angular/protractor" target="_blank" rel="external">protractor</a> 一款端对端的<code>angular apps</code> 测试框架。<code>star:4K</code></p>
</li>
<li><p><a href="https://github.com/n1k0/casperjs" target="_blank" rel="external">casperjs</a> 一个基于<code>PhantomJS</code>的开源导航脚本和测试工具。<code>star:4.8K</code></p>
</li>
</ul>
<ul>
<li><p><a href="https://github.com/karma-runner/karma" target="_blank" rel="external">Karma</a> 自动化完成单元测试，允许你在多个浏览器里执行<code>js</code>代码。让你的<code>TDD</code>变得简单，快速，有趣。<code>star:5.3K</code></p>
</li>
<li><p><a href="https://github.com/jasmine/jasmine" target="_blank" rel="external">jasmine</a>  是一个简易的<code>JS</code>单元测试框架， 用来测试<code>Javascript</code>代码。<code>star:9.1K</code>（6.28更新）</p>
</li>
<li><p><a href="https://github.com/chaijs/chai" target="_blank" rel="external">chai</a> 一个针对 <code>Node.js</code> 和浏览器的<code>TDD</code>(测试驱动开发)/<code>BDD</code>(行为驱动开发)的断言框架，可与任何 <code>JavaScript</code> 测试框架集成。<code>star:2K</code>（6.29更新）</p>
</li>
<li><p><a href="https://github.com/jquery/qunit" target="_blank" rel="external">Qunit</a> 一个很容易使用的js单元测试框架，该框架是由<code>jQuery</code>团队的成员所开发，并且是<code>jQuery</code>的官方测试套件。<code>star:3.3K</code>（6.29更新）</p>
</li>
</ul>
<h2 id="Workflow/构建工具">Workflow/构建工具</h2><ul>
<li><p><a href="https://github.com/gruntjs/grunt" target="_blank" rel="external">Grunt</a> 基于<code>Node.js</code>的项目构建工具。拥有数量庞大的插件，是一款优秀的前端自动化工具。<code>star:9500</code></p>
</li>
<li><p><a href="https://github.com/yeoman/yo" target="_blank" rel="external">yeoman</a> 一个强健的工具，库，及工作流程的组合。<code>star:960</code></p>
</li>
<li><p><a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">gulp</a> 基于<code>node.js</code>流的新一代前端构建系统。<code>star:14000</code></p>
</li>
<li><p><a href="https://github.com/spmjs/spm" target="_blank" rel="external">spm</a> 是 <code>CMD</code> 的包管理工具，需要和 <code>Sea.js</code> 配合使用。</p>
</li>
</ul>
<h2 id="canvas/数据可视化">canvas/数据可视化 </h2><ul>
<li><p><a href="https://github.com/ecomfe/echarts" target="_blank" rel="external">echarts</a> 基于<code>Canvas</code>，纯<code>Javascript</code>图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。<code>star:6900</code></p>
</li>
<li><p><a href="https://github.com/nnnick/Chart.js" target="_blank" rel="external">Chart.js</a> 使用<code>&lt;canvas&gt;</code>标签的简易HTML5图表。<code>star:14600</code></p>
</li>
<li><p><a href="https://github.com/soulwire/sketch.js" target="_blank" rel="external">sketch.js</a> 跨平台<code>JavaScript</code>创意编码框架，<code>gzip</code>压缩后仅有2kb。<code>star:1500</code></p>
</li>
<li><p><a href="https://github.com/mbostock/d3" target="_blank" rel="external">d3</a> 一个基于数据操作文档的<code>js</code>数据可视化框架，最流行的可视化库之一。<code>star:38000</code></p>
</li>
<li><p><a href="https://github.com/ecomfe/zrender" target="_blank" rel="external">zrender</a> 一个轻量级的<code>Canvas</code>类库，MVC封装，数据驱动，提供类<code>DOM</code>事件模型，让<code>canvas</code>绘图大不同！<code>star:850</code></p>
</li>
<li><p><a href="https://github.com/masayuki0812/c3" target="_blank" rel="external">c3</a> 一个基于 <code>D3.js</code> 的可重用 <code>JavaScript</code> 图表库。几乎零学习曲线。<code>star:4.5K</code>（6.28更新）</p>
</li>
</ul>
<h2 id="模块管理/加载器">模块管理/加载器</h2><ul>
<li><a href="https://github.com/ecomfe/esl" target="_blank" rel="external">ESL</a>   是一个浏览器端、符合<code>AMD</code>的标准加载器，适合用于现代<code>Web</code>浏览器端应用的入口与模块管理。</li>
</ul>
<p><code>ESL</code> vs <code>RequireJS</code></p>
<pre><code>体积更小 <span class="comment">(Smaller)</span>
性能更高 <span class="comment">(Higher performance)</span>
更健壮 <span class="comment">(More Robustness)</span>
不支持在非浏览器端使用 <span class="comment">(Browser only)</span>
依赖模块用时定义 <span class="comment">(Lazy define)</span>
</code></pre><ul>
<li><p><a href="https://github.com/seajs/seajs" target="_blank" rel="external">seajs</a> 一个遵循<code>CommonJS</code>规范的<code>JavaScript</code>模块加载器。提供简单、极致的模块化开发体验。<code>star:4100</code></p>
</li>
<li><p><a href="https://github.com/component" target="_blank" rel="external">Component</a> 一个模块化的<code>JavaScript</code>框架，同时也是面向前端的包管理器。</p>
</li>
</ul>
<h2 id="动画">动画</h2><ul>
<li><p><a href="https://github.com/daneden/animate.css" target="_blank" rel="external">animate.css</a> 一个跨浏览器的<code>CSS</code>动画库。简单易用易上手。<code>star:23000</code></p>
</li>
<li><p><a href="https://github.com/visionmedia/move.js" target="_blank" rel="external">move.js</a> 极小的 <code>JavaScript</code> 库,支持 <code>CSS3</code> 的动画效果,非常简单优雅。<code>star：2600</code></p>
</li>
<li><p><a href="https://github.com/CreateJS/TweenJS" target="_blank" rel="external">TweenJS</a> 是一个简单但强大的 <code>Javascript</code> 动画库。<code>CreateJS</code> 套件的一部分。<code>star:1500</code></p>
</li>
<li><p><a href="https://github.com/tictail/bounce.js" target="_blank" rel="external">bounce.js</a> 一个用于制作漂亮的 <code>CSS3</code> 关键帧动画的 <code>JavaScript</code><br>库,使用其特有的方式生成的动画效果。<code>star:3600</code></p>
</li>
<li><p><a href="https://github.com/thebird/Swipe" target="_blank" rel="external">Swipe</a> 号称最精确的<code>Slider</code>触摸库，专为移动设备优化。<code>star:4.7K</code></p>
</li>
<li><p><a href="https://github.com/tweenjs/tween.js" target="_blank" rel="external">tween.js</a> 一款可生成平滑动画效果的<code>js</code>动画库。<code>tween.js</code>允许你以平滑的方式修改元素的属性值。它可以通过设置生成各种类似CSS3的动画效果。<code>star:2.5K</code>(7.15更新)</p>
</li>
</ul>
<h2 id="插件">插件</h2><ul>
<li><p><a href="https://github.com/yanhaijing/zepto.fullpage" target="_blank" rel="external">zepto.fullpage</a> 专注于移动端的全屏滚动插件。<code>star:510</code></p>
</li>
<li><p><a href="https://github.com/alvarotrigo/fullPage.js" target="_blank" rel="external">fullPage.js</a> pc端的全屏滚动插件。 <code>star:9500</code> <a href="http://alvarotrigo.com/fullPage/#firstPage" target="_blank" rel="external">view demo</a> </p>
</li>
<li><p><a href="https://github.com/peachananr/onepage-scroll" target="_blank" rel="external">onepage-scroll</a> 可以轻松建立一个动感的响应式的滚动效果页面，比较适用于单页面的专题站。支持现代浏览器和IE8以上版本。<a href="http://www.thepetedesign.com/demos/onepage_scroll_demo.html" target="_blank" rel="external">View demo</a> 。<code>star:7700</code></p>
</li>
<li><p><a href="https://github.com/kenwheeler/slick" target="_blank" rel="external">slick</a> 一款完全响应式的 <code>jQuery</code> 图片滚动插件，能够根据容器自动适应宽度。<code>star:10000</code> <a href="http://kenwheeler.github.io/slick/" target="_blank" rel="external">view demo</a></p>
</li>
<li><p><a href="https://github.com/nicinabox/superslides" target="_blank" rel="external">superslides</a> 致力于解决网站大部分特效展示问题。网站上常用的“焦点图/幻灯片”“Tab标签切换”“图片滚动”“无缝滚动”等只需要一个<code>SuperSlide</code>即可解决！ <a href="http://nicinabox.com/superslides" target="_blank" rel="external">view demo</a> <code>star:1100</code> </p>
</li>
<li><p><a href="https://github.com/davist11/jQuery-One-Page-Nav" target="_blank" rel="external">jQuery-One-Page-Nav</a> 当用户滚动网页时，实现平滑滚动和智能导航。<code>star:1100</code></p>
</li>
<li><p><a href="https://github.com/jssor/slider" target="_blank" rel="external">slider</a> 一个<code>jquery</code>完全开源的<code>JavaScript</code>代码库，用户可以开发，调试和深度定制自己的滑块。<code>star:850</code> <a href="http://www.jssor.com/demos/index.html" target="_blank" rel="external">view demo</a></p>
</li>
</ul>
<h2 id="框架、库和组件">框架、库和组件</h2><ul>
<li><p><a href="https://github.com/Polymer/polymer" target="_blank" rel="external">polymer</a> <code>web</code>组件构建框架。一套以“一切皆组件、最少化代码量、最少框架限制”为设计理念的<code>Web UI</code>框架。 <code>star:9900</code></p>
</li>
<li><p><a href="https://github.com/bartaz/impress.js" target="_blank" rel="external">impress.js</a> 创建令人兴奋的演示。使用<code>CSS3</code>的转换和过渡，这个库允许你创建令人印象深刻的演示文稿。<a href="http://bartaz.github.io/impress.js/#/bored" target="_blank" rel="external">view demo</a>。<code>star:24300</code></p>
</li>
<li><p><a href="https://github.com/driftyco/ionic" target="_blank" rel="external">ionic</a> 先进的<code>HTML5</code> 移动端开发框架。帮助开发者使用HTML5, CSS3和<code>js</code>做出不可思议的<code>hybrid app</code>。<code>star:17000</code></p>
</li>
<li><p><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="external">reveal.js</a> 基于<code>CSS3</code>的3D幻灯片工具。能够制作绚丽的演示文稿并生成<code>HTML</code>格式，将它发布到web上。<code>star:21500</code> <a href="http://lab.hakim.se/reveal-js/#/" target="_blank" rel="external">view demo</a></p>
</li>
</ul>
<ul>
<li><p><a href="https://github.com/yahoo/pure/" target="_blank" rel="external">pure.css</a> 一组很小的，响应式的<code>css</code>组件，你可以在网页的项目上到处使用。<code>star:12000</code></p>
</li>
<li><p><a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">three.js</a> 是<code>JavaScript</code>编写的<code>WebGL</code>第三方库。提供了非常多的3D显示功能。<code>star:20000</code></p>
</li>
<li><p><a href="https://github.com/NUKnightLab/TimelineJS" target="_blank" rel="external">TimelineJS</a> 轻松制作时间轴。<code>star:8000</code></p>
</li>
<li><p><a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="external">jquery-pjax</a> 对<code>ajax</code> 和 <code>pushState</code>的封装，让你可以很方便的使用<code>pushState</code>技术，用以实现页面无刷新加载。<code>star:11500</code></p>
</li>
<li><p><a href="https://github.com/isagalaev/highlight.js" target="_blank" rel="external">highlight.js</a> <code>javascript</code>语法高亮。既可以运行在浏览器端也可以运行在服务端。<code>star:5500</code></p>
</li>
<li><p><a href="https://github.com/tj/commander.js" target="_blank" rel="external">commander.js</a> <code>Node.js</code>命令行工具。<code>star:3800</code></p>
</li>
<li><p><a href="https://github.com/mozilla/togetherjs" target="_blank" rel="external">togetherjs</a> 由<code>Mozilla</code>打造的一款可以给网站添加实时协作功能的<code>JavaScript</code>库。<code>star:5K</code></p>
</li>
<li><p><a href="https://github.com/nbubna/HTML" target="_blank" rel="external">HTML.js</a> 轻量级的简化与<code>DOM</code>操作的js库。<a href="http://nbubna.github.io/HTML/" target="_blank" rel="external">view demo</a> <code>star:1.5K</code></p>
</li>
<li><p><a href="https://github.com/meanjs/mean" target="_blank" rel="external">MEAN.JS</a> 全栈式javascript，使用<code>MongoDB, Express,
AngularJS</code>和<code>Node.js</code>。<code>star:2.2K</code></p>
</li>
<li><p><a href="https://github.com/sofish/wechat.js" target="_blank" rel="external">wechat.js</a> 微信相关的 js 操作：分享、网络、菜单。<code>star:700</code></p>
</li>
<li><p><a href="https://github.com/blueimp/JavaScript-Load-Image" target="_blank" rel="external">JavaScript-Load-Image</a> 一个<code>js</code>加载和转换图像文件的库。 <code>star:1.2K</code> <a href="https://blueimp.github.io/JavaScript-Load-Image/" target="_blank" rel="external">view<br>demo</a></p>
</li>
<li><p><a href="https://github.com/usablica/progress.js" target="_blank" rel="external">progress.js</a> 一个 <code>js</code> 和 <code>CSS3</code>的库，帮助开发人员为网页上的每个对象创建和管理进度条效果。<code>star:1.6K</code> <a href="http://usablica.github.io/progress.js/" target="_blank" rel="external">view demo</a></p>
</li>
<li><p><a href="https://github.com/zurb/foundation" target="_blank" rel="external">foundation</a> 号称世界上最先进的响应式前端框架，也是一款<code>Mobile First</code>的框架。<code>star:21K</code></p>
</li>
<li><p><a href="https://github.com/andrewplummer/Sugar" target="_blank" rel="external">Sugar</a> 一个<code>JavaScript</code>库。它扩展了现有的<code>JS</code>对象的方法，让你可以用更少的代码做更多的事情。<code>star:2.8K</code></p>
</li>
<li><p><a href="https://github.com/tastejs/todomvc" target="_blank" rel="external">todomvc</a> 帮你挑选一款MV<em>框架，它使用不同的最流行的`js MV</em><code>框架实现了一个相同的</code>Todo<code>应用。</code>star:13K`</p>
</li>
<li><p><a href="https://github.com/SlexAxton/yepnope.js" target="_blank" rel="external">yepnope.js</a> 这是一个异步的条件加载框架，速度超快，只为用户加载需要的脚本。使用非常简单，非常有用！<code>star:2.5K</code></p>
</li>
<li><p><a href="https://github.com/callemall/material-ui" target="_blank" rel="external">Material UI</a> 是一个 <code>CSS</code> 框架和一组实现谷歌 Material Design 设计规范的 React<br>组件。<code>star:8.8K</code>（6.28更新）</p>
</li>
<li><p><a href="https://github.com/dbushell/Pikaday" target="_blank" rel="external">Pikaday</a> 是一个 <code>JavaScript</code> 日期选择器，特点是轻量级、无依赖和模块化的<br><code>CSS</code>。<code>star:2.8K</code> <a href="http://dbushell.github.io/Pikaday/" target="_blank" rel="external">view demo</a>(7.1更新)</p>
</li>
</ul>
<ul>
<li><p><a href="https://github.com/yyx990803/vue" target="_blank" rel="external">vuejs</a> 用于构建交互式的 Web 界面的库。它提供了 <code>MVVM</code> 数据绑定和一个可组合的组件系统,具有简单、灵活的 API。<code>star:6K</code>（7.12更新）</p>
</li>
<li><p><a href="https://github.com/meteor/meteor" target="_blank" rel="external">meteor</a> 超简单的，数据库无处不在的，用于自动化和简化实时运行的 <code>Web</code> 应用程序的开发。纯<code>JavaScript</code>的Web框架。<code>star:27K</code>（7.12更新）</p>
</li>
<li><p><a href="https://github.com/fex-team/webuploader" target="_blank" rel="external">webuploader</a><br>一个简单的以<code>HTML5</code>为主，<code>FLASH</code>为辅的现代文件上传组件。支持大文件分片并发上传，极大的提高了文件上传效率。<code>star:1.8K</code> </p>
</li>
</ul>
<h2 id="移动端">移动端</h2><ul>
<li><p><a href="https://github.com/thebird/swipe" target="_blank" rel="external">Swiper</a> 加速移动触摸滑块与硬件之间的转换。<code>star:5000</code>。</p>
</li>
<li><p><a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="external">hammer.js</a> 一个支持多点触摸的手势库。<code>star:11000</code></p>
</li>
<li><p><a href="https://github.com/am-team/amDoc" target="_blank" rel="external">amDoc</a> 无线<code>Web</code>解决方案 - 文档规范指南</p>
</li>
<li><p><a href="https://github.com/allmobilize/amazeui" target="_blank" rel="external">amazeui</a>  移动优先的跨屏前端框架。面向<code>HTML5</code>开发，使用<code>css3</code>做动画和交互。<code>star:4.1K</code></p>
</li>
<li><p><a href="https://github.com/madrobby/zepto/" target="_blank" rel="external">Zepto</a>  一款面向移动端设备、<code>API</code>与<code>jQuery</code>兼容的基础库。</p>
</li>
<li><p><a href="https://github.com/dcloudio/mui" target="_blank" rel="external">mui</a> 最接近原生APP体验的高性能框架 。<code>star:1.1K</code>（6.28更新）</p>
</li>
</ul>
<h2 id="Node-js相关">Node.js相关</h2><p><a href="http://nodeframework.com/" target="_blank" rel="external">http://nodeframework.com/</a> 专门收集<code>node.js</code>的<code>web</code>框架的网站。其项目同样均托管在<code>github</code>上。</p>
<ul>
<li><p><a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="external">nodeclub</a> 使用 <code>Node.js</code> 和 <code>MongoDB</code> 开发的社区系统。<code>star:3000</code></p>
</li>
<li><p><a href="https://github.com/nswbmw/N-chat" target="_blank" rel="external">N-chat</a> 使用 <code>Express + Socket.IO</code> 搭建的多人聊天室 。<code>star:300</code></p>
</li>
<li><p><a href="https://github.com/nswbmw/N-blog" target="_blank" rel="external">N-blog</a> 使用 <code>Express + MongoDB</code> 搭建多人博客。<code>star:1800</code></p>
</li>
<li><p><a href="https://github.com/node-inspector/node-inspector" target="_blank" rel="external">node-inspector</a> 基于<code>Blink</code>开发者工具的<code>Node.js</code>调试器。<code>star:7000</code></p>
</li>
<li><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">node-lessons</a>：<code>Node.js</code>包教不包会。<code>star:2.5K</code></p>
</li>
<li><p><a href="https://github.com/ksky521/nodePPT" target="_blank" rel="external">nodePPT</a>  使用<code>nodejs</code>写的网络幻灯片。可能是迄今为止最好的网页版<code>PPT</code>。<code>star:1.6K</code> <a href="http://qdemo.sinaapp.com/" target="_blank" rel="external">view demo</a></p>
</li>
<li><p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo</a> 一款快捷，简单，强大的博客框架，基于<code>Nodejs</code>。<code>star:5.2K</code></p>
</li>
<li><p><a href="https://github.com/koajs/koa" target="_blank" rel="external">koa</a> 下一代<code>Node.js</code>  Web 框架。由 <code>Express</code> 团队设计。<code>star:6.3K</code></p>
</li>
<li><p><a href="https://github.com/sindresorhus/awesome-nodejs" target="_blank" rel="external">awesome-nodejs</a> 关于<code>Nodejs</code> 包和资源的收集。<code>star:7K</code></p>
</li>
<li><p><a href="https://github.com/senchalabs/connect" target="_blank" rel="external">connect</a> <code>Node</code>平台的中间件框架。<code>Express</code>就是基于<code>Connect</code>开发的。<code>star:5.6K</code>（6.29更新）</p>
</li>
<li><p><a href="https://github.com/tj/n" target="_blank" rel="external">n</a> node版本管理，tj大神所写。<code>star:2.7K</code></p>
</li>
<li><p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> node版本管理，通过bash脚本来管理。<code>star:7.5K</code></p>
</li>
</ul>
<h2 id="React相关">React相关</h2><ul>
<li><p><a href="https://github.com/js-next/react-style" target="_blank" rel="external">react-style</a> 是 <code>React.js</code> 可维护的样式组件</p>
</li>
<li><p><a href="https://github.com/react-component" target="_blank" rel="external">react-component</a>  基于<code>reactjs</code>的组件。</p>
</li>
<li><p><a href="https://github.com/facebook/react-native" target="_blank" rel="external">react-native</a> 一个用<code>React</code>构建<code>native apps</code>的框架。<code>star:15000</code></p>
</li>
<li><p><a href="https://github.com/ele828/react-native-guide" target="_blank" rel="external">react-native-guide</a>  汇集了<code>react-native</code>学习资源与各类开源app。<code>star:850</code></p>
</li>
<li><p><a href="https://github.com/enaqx/awesome-react" target="_blank" rel="external">awesome-react</a> 关于<code>react</code>的工具，资源，视频的集合。<code>star:700</code></p>
</li>
<li><p><a href="https://github.com/facebook/flux" target="_blank" rel="external">Flux</a> 是一个<code>Facebook</code>开发的、利用单向数据流实现的应用架构，用于<br><code>React</code>。<code>Flux</code>应用有三个主要的部分组成：调度程序、存储和视图（React 组件）。<code>star:6.8K</code>（6.28更新）</p>
</li>
<li><p><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="external">iscroll</a> 高性能，体积小，无外部依赖，跨平台的滚动组件 star:6K（7.19更新）</p>
</li>
</ul>
<h2 id="HTML5">HTML5</h2><ul>
<li><p><a href="https://github.com/mozilla/BrowserQuest" target="_blank" rel="external">Browserquest</a>: <code>Mozilla</code>开发的<code>HTML5</code>多人在线游戏。<code>star:5200</code></p>
</li>
<li><p><a href="https://github.com/videojs/video.js" target="_blank" rel="external">video.js</a> 开源的HTML5和Flash视频播放器。支持自定义进度条、按钮以及工具栏的底色。<code>star:9.1K</code></p>
</li>
<li><p><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="external">html5shiv</a> 主要解决<code>HTML5</code>提出的新的元素不被<code>IE6-9</code>识别。<code>star:6K</code>(7.15更新)</p>
</li>
<li><p><a href="https://github.com/brunch/brunch/" target="_blank" rel="external">brunch</a> 快速的前端 <code>HTML5</code> 构建工具。star:4.5K（7.19更新）</p>
</li>
<li><p><a href="https://github.com/uikit/uikit" target="_blank" rel="external">ulkit</a> 一个轻量级的、模块化前端框架，它被用于快速开发强大的web界面。也是一款优秀的响应式HTML5 框架。<code>star:5.3K</code> (8.3更新)</p>
</li>
</ul>
<h2 id="其他">其他</h2><ul>
<li><p><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">javascript-style-guide</a> 最合理的使用<code>javascript</code>的方法。 <code>star:18000</code></p>
</li>
<li><p><a href="https://github.com/AlloyTeam/Mars" target="_blank" rel="external">Mars</a> 腾讯移动<code>Web</code>前端知识库。<code>star:1600</code></p>
</li>
</ul>
<ul>
<li><p><a href="https://github.com/adobe/brackets" target="_blank" rel="external">brackets</a> 一款使用 HTML，CSS，JavaScript 创建的开源的针对 Web 开发的编辑器。<code>star:23000</code></p>
</li>
<li><p><a href="https://github.com/TryGhost/Ghost" target="_blank" rel="external">Ghost</a> <code>Node.js</code>开发最新博客系统, 简单简洁, 响应式设计, 支持完全自定义, 免费, 专注博客。<code>star:16000</code></p>
</li>
<li><p><a href="https://github.com/nodejs/io.js" target="_blank" rel="external">io.js</a>  从<code>NodeJS</code>里分离出来的一条分支。<code>star:13000</code></p>
</li>
<li><p><a href="https://github.com/gabrielecirulli/2048" target="_blank" rel="external">2048 游戏</a> <a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">view demo</a> <code>star:7000</code></p>
</li>
<li><p><a href="https://github.com/fex-team/ueditor" target="_blank" rel="external">ueditor</a> 百度前端团队出品的富本文编辑器。<code>star:1.1K</code></p>
</li>
</ul>
<h2 id="模板引擎">模板引擎</h2><ul>
<li><p><a href="https://github.com/wycats/handlebars.js" target="_blank" rel="external">Handlebars.js</a> 一个<code>js</code>语义模板库，能让你轻松高效的编写语义化模板。<code>star:8.6K</code>(6.29 update)</p>
</li>
<li><p><a href="https://github.com/aui/artTemplate" target="_blank" rel="external">artTemplate</a>  性能卓越的 <code>js</code> 模板引擎。<code>star:1.7K</code></p>
</li>
<li><p><a href="https://github.com/jadejs/jade" target="_blank" rel="external">jade</a> 一款高性能简洁易懂的模板引擎，<code>Jade</code>是<code>Haml</code>的<code>Javascript</code>实现。<code>star:8.7K</code></p>
</li>
</ul>
<h2 id="浏览器兼容方案">浏览器兼容方案 </h2><ul>
<li><p><a href="https://github.com/paulmillr/es6-shim" target="_blank" rel="external">es6-shim</a> 提供兼容性垫片，使ES6能兼容于传统的<code>JavaScript</code>引擎。<code>star:1.5K</code>(7.15更新)</p>
</li>
<li><p><a href="https://github.com/Modernizr/Modernizr" target="_blank" rel="external">Modernizr</a> 用来检测浏览器功能支持情况的<code>JavaScript</code>库,可以检测18项<code>CSS3</code>功能以及40多项关于<code>HTML5</code>的功能。<code>star:16000</code></p>
</li>
<li><p><a href="https://github.com/necolas/normalize.css" target="_blank" rel="external">normalize.css</a> 一个可定制的 <code>CSS</code> 文件，使浏览器呈现的所有元素，更一致和符合现代标准。支持IE8+。<code>star:17000</code></p>
</li>
<li><p><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="external">html5shiv</a> 主要解决<code>HTML5</code>提出的新的元素不被<code>IE6-9</code>识别。<code>star:6K</code>(7.15更新)</p>
</li>
<li><p><a href="https://github.com/paulirish/css3please" target="_blank" rel="external">css3please</a> 跨浏览器自动生成<code>css3</code>前缀</p>
</li>
<li><p><a href="https://github.com/babel/babel/" target="_blank" rel="external">Babel</a> 是一款为了写下一代js的编译器，无需等待浏览器支持就可以使用新的语法。<code>star：8.3K</code> (7.29更新)</p>
</li>
</ul>
<h2 id="高产大牛">高产大牛</h2><ul>
<li><p><a href="https://github.com/yyx990803" target="_blank" rel="external">Evan You</a>  前端轻量级框架<code>MVVM</code>框架<code>vue.js</code>作者，前<code>Google</code>工程师。<code>followers:1.6K</code></p>
</li>
<li><p><a href="https://github.com/tj" target="_blank" rel="external">TJ Holowaychuk</a>  Luna 编程语言, <code>Koa, Express, Stylus, Cluster, Mocha, Jade, node-canvas, component</code> 等知名开源项目的创建和贡献者。 <code>followers:14.1K</code></p>
</li>
<li><p><a href="https://github.com/paulirish" target="_blank" rel="external">PaulIrish</a> 著名的前端开发工程师，同时他也是<code>Chrome</code>开发者关系团队成员，jQuery团队成员，<code>Modernizr、Yeoman、CSS3 Please</code>和<code>HTML5 Boilerplate</code>的<code>lead developer</code>。<code>followers:15.7K</code></p>
</li>
<li><p><a href="https://github.com/mbostock" target="_blank" rel="external">Mike Bostock</a> 知名可视化库 <code>D3.js</code>的主要作者。<code>followers:8.3K</code></p>
</li>
<li><p><a href="https://github.com/necolas" target="_blank" rel="external">Nicolas Gallagher</a> <code>Normalize.css</code> 作者。<code>followers:3.6K</code></p>
</li>
<li><p><a href="https://github.com/RubyLouvre" target="_blank" rel="external">司徒正美</a> 前端迷你<code>MVVM</code>框架<code>Avalon</code>作者。<code>followers:2.1K</code></p>
</li>
</ul>
<h2 id="优秀开源组织">优秀开源组织</h2><ul>
<li><a href="https://github.com/AlloyTeam" target="_blank" rel="external">AlloyTeam</a> 腾讯 <code>Web</code> 前端团队。 </li>
</ul>
<ul>
<li><a href="https://github.com/fex-team" target="_blank" rel="external">fex-team</a> 百度前端团队。</li>
</ul>
<p>本篇文章会持续更新，欢迎收藏。</p>
<blockquote>
<p>文章已推送至我的<code>github</code>，欢迎<code>pullrequest</code>：<a href="https://github.com/hawx1993/github-FE-project" target="_blank" rel="external">https://github.com/hawx1993/github-FE-project</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-native-js" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/18/native-js/" class="article-date">
  	<time datetime="2015-08-18T10:17:17.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/native-js/">关于原生js的一些研究</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="callee和caller">callee和caller</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(arguments.callee)</span>;<span class="comment">//指向拥有这个arguments对象的函数，即inner()</span>
    console.<span class="built_in">log</span><span class="params">(arguments.callee.caller)</span>;<span class="comment">//这个属性保存着调用当前函数的函数的引用,即outer()</span>
    console.<span class="built_in">log</span><span class="params">(inner.caller)</span>;<span class="comment">//[Function: outer]</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span>{</span>
    inner<span class="params">()</span>;
}
outer<span class="params">()</span>;
</code></pre><p><code>callee</code>放回正在执行的函数本身的引用，它是<code>arguments</code>的一个属性<br><code>caller</code> 返回一个函数的引用，这个函数调用了当前的函数。</p>
<p>严格模式下，不允许访问<code>arguments.callee</code>和<code>arguments.caller</code>属性，主要体现在<code>arguments.[[Get]]</code>内部方法</p>
<p>严格模式下，<code>arguments，arguments.callee，arguments.caller，arguments.callee.caller</code>也不允许再被赋值。如下代码所示：</p>
<pre><code><span class="pi">'use strict'</span>;
<span class="comment">// 两次都是1</span>
<span class="keyword">void</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>{
    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);
    a = <span class="number">2</span>;
    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);
}(<span class="number">1</span>);


<span class="comment">//function(){}(); 会运行错误, 如下可以正确被运行.</span>

<span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);<span class="comment">//hi</span>
}();
</code></pre><p>在使用立即执行的函数表达式时，可以利用 <code>void</code> 运算符让 <code>JavaScript</code> 引擎把一个函数识别成<code>函数表达式</code>而不是函数声明（语句）。</p>
<p>###实参和形参</p>
<pre><code><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>{
    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);<span class="comment">//3,表示实参长度</span>
    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.length);<span class="comment">//2，表示形参长度</span>
};

add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);
</code></pre><h2 id="Array-prototype-slice-call(arguments)">Array.prototype.slice.call(arguments)</h2><p><code>slice</code>有两个用法，一个是<code>String.slice</code>，一个是<code>Array.slice</code>，第一个返回的是字符串，第二个返回的是数组。</p>
<p><code>Array.prototype.slice.call(arguments)</code>能够将<code>arguments</code>转成数组，那么就是<code>arguments.toArray().slice()</code>;</p>
<p>因为<code>arguments</code>并不是真正的数组对象，只是与数组类似而已，所以它并没有<code>slice</code>这个方法，而<code>Array.prototype.slice.call(arguments)</code>可以理解成是将<code>arguments</code>转换成一个数组对象，让<code>arguments</code>具有<code>slice()</code>方法。 比如：</p>
<pre><code>var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
console.<span class="built_in">log</span>(Array.prototype.slice.call(arr,<span class="number">2</span>));<span class="comment">//[3,4]</span>
</code></pre><p>同样，还有<code>Array.prototype.forEach.call()</code>，<code>forEach()</code> 方法让数组的每一项都执行一次给定的函数。   </p>
<h2 id="String()">String()</h2><p>我们可以用<code>String()</code>来确定某一变量是否是<code>null</code>或者<code>undefined</code></p>
<pre><code><span class="keyword">var</span> a , b = <span class="keyword">null</span>;
<span class="built_in">String</span>(a);<span class="comment">//undefined</span>
<span class="built_in">String</span>(b);<span class="comment">//null</span>
</code></pre><p>直接调用<code>String()</code>作为方法时，将会执行类型转换，返回经过<code>toString(value)</code>得到的字符串字面量（与<code>new String()</code>不同），或者空字符串（’’）.</p>
<h2 id="window_对象">window 对象</h2><pre><code><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
       (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
           <span class="keyword">var</span> root = <span class="keyword">this</span>;
           <span class="built_in">console</span>.log(root);<span class="comment">//即window对象</span>
       })();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>打开控制台，你可以看到<code>window</code>对象的一系列属性和方法：</p>
<h2 id="new_function">new function</h2><pre><code><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);<span class="comment">//function</span>

<span class="keyword">var</span> b = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);<span class="comment">//object</span>

<span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Function</span> ();
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);<span class="comment">//function</span>
</code></pre><p><code>new function</code> 是一个<code>JavaScript</code>中用户自定义的对象    </p>
<pre><code><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>{
    <span class="keyword">this</span>.name = name;
};
<span class="keyword">var</span> b = <span class="keyword">new</span> obj(<span class="string">'trigkit4'</span>);
<span class="built_in">console</span>.log(b.name);  
</code></pre><h2 id="js中的false和true">js中的false和true</h2><pre><code><span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">('')</span>)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(null)</span>)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(<span class="literal">undef</span>ined)</span>)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(<span class="number">0</span>)</span>)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(<span class="literal">false</span>)</span>)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(NaN)</span>)</span>;<span class="comment">//false</span>

<span class="comment">//true</span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">(' ')</span>)</span>;<span class="comment">//true    </span>
console.<span class="built_in">log</span><span class="params">(Boolean<span class="params">('NaN')</span>)</span>;<span class="comment">//true</span>
</code></pre><p>除了<code>false，null，undefined</code>，空字符串<code>&#39;&#39;</code>，数字0和<code>NaN</code>以外，其他所有值都被当做是真，包括<code>true</code>，字符串<code>&quot;&quot;</code>里包含的值，以及所有对象。</p>
<h2 id="valueOf()_和_toString()">valueOf() 和 toString()</h2><p><code>valueOf()</code>和<code>toString()</code>方法是所有<code>ECMAScript</code>对象拥有的内置方法。操作对象时，<code>valueOf()</code>和<code>toString()</code>会被隐式的调用。</p>
<pre><code><span class="comment">//valueOf()</span>
console.<span class="built_in">log</span><span class="params">(Object.valueOf<span class="params">()</span>)</span>;<span class="comment">//[Function: Object]</span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.valueOf<span class="params">()</span>)</span>;<span class="comment">//{}</span>

var boo = new Boolean<span class="params">(<span class="number">1</span>)</span>;
console.<span class="built_in">log</span><span class="params">(boo.valueOf<span class="params">()</span>)</span>;<span class="comment">//true</span>

var bar = Boolean<span class="params">(<span class="number">0</span>)</span>;
console.<span class="built_in">log</span><span class="params">(bar.valueOf<span class="params">()</span>)</span>;<span class="comment">//false</span>

var <span class="built_in">str</span> = String<span class="params">(<span class="string">"trigkit4"</span>)</span>;
console.<span class="built_in">log</span><span class="params">(str.valueOf<span class="params">()</span>)</span>;<span class="comment">//trigkit4</span>

console.<span class="built_in">log</span><span class="params">(null.valueOf<span class="params">()</span>)</span>;<span class="comment">//TypeError</span>
console.<span class="built_in">log</span><span class="params">(<span class="literal">undef</span>ined.valueOf<span class="params">()</span>)</span>;<span class="comment">//TypeError</span>

<span class="comment">//toString()</span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString<span class="params">()</span>)</span>;<span class="comment">//[object Object]</span>
console.<span class="built_in">log</span><span class="params">(Object.toString<span class="params">()</span>)</span>;<span class="comment">//function Object() { [native code] }</span>
Object.prototype.toString.call<span class="params">(null)</span>;<span class="comment">//[object Null]</span>
Object.prototype.toString.call<span class="params">(<span class="literal">undef</span>ined)</span>;<span class="comment">//[object Undefined]</span>
{a: 'b'}.toString<span class="params">()</span>;<span class="comment">//[object Object]</span>
</code></pre><p><code>valueOf()</code>方法的目的是将对象转换成最有意义的原始值(<code>[[PrimitiveValue]]</code>)。即<code>ECMAScript</code>的5种基本类型中的三种，<code>布尔值、数字、字符串</code>。</p>
<p>当<code>valueOf</code>方法被调用时，会调用内置的<code>ToObject</code>，并将<code>this</code>作为参数传进去。<code>ToObject</code>检测会根据参数类型进行数值的转换：</p>
<pre><code>Undefined - 抛出TypeError异常
Null - 抛出TypeError异常
Boolean - 创建一个Boolean对象，调用ToBoolean生成<span class="string">[[PrimitiveValue]]</span>
Number - 创建一个Number对象，调用ToNumber生成<span class="string">[[PrimitiveValue]]</span>
String - 创建一个String对象，调用ToString生成<span class="string">[[PrimitiveValue]]</span>
Object - 对象本身
</code></pre><p><code>ECMAScript</code>对象的大多数操作的转换结果是字符串，这两个方法的结果是相同的。但是如果操作的对象为<code>Number</code>、<code>Boolean</code>或者<code>Date</code>，结果就不同了。</p>
<pre><code><span class="keyword">var</span> foo = {
    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="string">"foo"</span>;
    },
    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="number">5</span>;
    }
};

<span class="built_in">console</span>.log(foo + <span class="string">"bar"</span>); <span class="comment">// 5bar</span>
<span class="built_in">console</span>.log([foo, <span class="string">"bar"</span>].join(<span class="string">""</span>)); <span class="comment">// foobar</span>
</code></pre><p>在这个上下文环境中，我们使用<code>&quot;+&quot;</code>操作符来使字符串连接，但是，<code>foo</code>并没有使用<code>toString</code>来转换成字符串，它使用<code>valueOf</code>转换成一个<code>number</code>，这并不是我们想要的，<br>但它是如何工作的，这是<code>+</code>运算符的算术和字符串连接超载的副作用。<code>&quot;+&quot;</code>操作符有一个明确的处理过程：</p>
<pre><code><span class="number">1.</span>评估左手侧，并得到该值。
<span class="number">2.</span>评估右手侧，并获得该值。
<span class="number">3.</span>同时在左手和右手侧调用ToPrimitive（无提示）
<span class="number">4.</span>如果任何原始值是一个字符串，然后跳到<span class="number">7</span>。
<span class="number">5.</span>在这两个值调用ToNumber。
<span class="number">6.</span>返回值的总和。
<span class="number">7.</span>在这两个值调用toString。
<span class="number">8.</span>返回的值连接起来
</code></pre><h2 id="setInterval和setTimeout">setInterval和setTimeout</h2><pre><code>alert(<span class="number">1</span>); 
setTimeout(<span class="string">"alert(2)"</span>, <span class="number">0</span>); 
alert(<span class="number">3</span>); 
</code></pre><p>执行顺序为：1，3，2，虽然延时了0ms  </p>
<pre><code>setTimeout <span class="number">0</span>  <span class="comment">//正常情况下javascript都是按照顺序执行的。但是我们可能让该语句</span>
后面的语句执行完再执行本身，这时就可以用到setTimeout延时<span class="number">0</span>ms来实现了。
</code></pre><h2 id="cookie的创建和删除">cookie的创建和删除</h2><p><code>cookie</code>可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</p>
<pre><code>document.cookie = “user = 值<span class="comment">;expires = 过期时间;path = 路径访问;</span>
domain = 域名访问<span class="comment">;secure = 安全的https限制通信"</span>
</code></pre><p>###cookie的创建方式<br>设置<code>cookie</code>我们一般都封装成一个函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">addCookie</span><span class="params">(sName,sValue,day)</span> {</span>
    var expireDate = new Date<span class="params">()</span>;
    expireDate.setDate<span class="params">(expireDate.getDate<span class="params">()</span>+day)</span>;;
<span class="comment">//设置失效时间</span>
    document.cookie = escape<span class="params">(sName)</span> + '=' + escape<span class="params">(sValue)</span> +';
    expires=' + expireDate.toGMTString<span class="params">()</span>;<span class="number">6</span> <span class="comment">//escape()汉字转成unicode编码,toGMTString() 把日期对象转成字符串</span>
} 
</code></pre><p>###删除cookie<br>为了删除一个<code>cookie</code>，可以将其过期时间设定为一个过去的时间，例如：</p>
<pre><code><span class="comment">//获取当前时间</span>
    <span class="built_in">var</span> <span class="built_in">date</span>=<span class="literal">new</span> <span class="built_in">Date</span>();
<span class="comment">//将date设置为过去的时间</span>
    <span class="built_in">date</span><span class="built_in">.</span>setTime(<span class="built_in">date</span><span class="built_in">.</span>getTime()-<span class="number">10000</span>);
<span class="comment">//将userId这个cookie删除</span>
    document<span class="built_in">.</span>cookie=<span class="string">"userId=828; expires="</span>+<span class="built_in">date</span><span class="built_in">.</span>toGMTString();
</code></pre><p>###给cookie设置终止日期<br>到现在为止，所有的<code>cookie</code>都是单会话<code>cookie</code>，即浏览器关闭后这些<code>cookie</code>将会丢失，事实上这些<code>cookie</code>仅仅是存储在内存中，而没有建立相应的硬盘文件。<br>在实际开发中，<code>cookie</code>常常需要长期保存，例如保存用户登录的状态。这可以用下面的选项来实现：</p>
<pre><code><span class="built_in">document</span>.cookie=<span class="string">"userId=828; expiress=GMT_String"</span>;
</code></pre><p>其中<code>GMT_String</code>是以<code>GMT</code>格式表示的时间字符串，这条语句就是将<code>userId</code>这个<code>cookie</code>设置为<code>GMT_String</code>表示的过期时间，超过这个时间，<code>cookie</code>将消失，不可访问。例如：如果要将<code>cookie</code>设置为10天后过期，可以这样实现：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">language</span>=<span class="value">"JavaScript"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="comment">//获取当前时间</span>
    <span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();
    <span class="keyword">var</span> expiresDays=<span class="number">10</span>;
<span class="comment">//将date设置为10天以后的时间</span>
    date.setTime(date.getTime()+expiresDays*<span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>);
<span class="comment">//将userId和userName两个cookie设置为10天后过期</span>
    <span class="built_in">document</span>.cookie=<span class="string">"userId=828; userName=hulk; expires="</span>+date.toGMTString();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> 
</code></pre><p>对象和函数可以如数组一样，用属性名或方法名作为下标来访问：</p>
<h2 id="对象的创建">对象的创建</h2><pre><code><span class="comment">//对象的创建</span>
<span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span><span class="params">()</span></span>{}
<span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyFunc();<span class="comment">//使用new操作符，借助MyFun函数，就创建了一个对象</span>
<span class="keyword">var</span> obj2 = <span class="keyword">new</span> MyFunc;<span class="comment">//函数也可以没有括号，但仍将调用该函数</span>
</code></pre><p>可以把上面的代码改写成这种等价形式：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span><span class="params">()</span></span>{};
<span class="keyword">var</span> obj1 = {};<span class="comment">//创建一个对象</span>
MyFunc.call(obj1);<span class="comment">//将obj1对象作为this指针调用MyFunc函数</span>
</code></pre><h2 id="作用域">作用域</h2><p>通过自执行的匿名函数你可以把所有原本属于全局的变量都隐藏起来：</p>
<pre><code><span class="comment">//创建一个新的匿名函数，作为包装</span>
(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">//变量原本应该是全局的</span>
    <span class="keyword">var</span> msg = <span class="string">"Thanks for visiting"</span>;

    <span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(msg);
    };
})();
</code></pre><p>上下文对象是通过<code>this</code>变量体现的，这个变量永远指向当前代码所处的对象中。</p>
<pre><code><span class="keyword">var</span> obj = {
    yes : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="comment">//this == obj</span>
        <span class="keyword">this</span>.val = <span class="literal">true</span>;
    },
    no : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">this</span>.val = <span class="literal">false</span>;
    }
};
<span class="built_in">console</span>.log(obj.val == <span class="literal">null</span>);<span class="comment">//true</span>
<span class="comment">//执行了yes函数后，将val属性与'obj'对象关联起来</span>
obj.yes();
<span class="built_in">console</span>.log(obj.val == <span class="literal">true</span>);<span class="comment">//true</span>
</code></pre><h2 id="String_原型方法的扩展">String 原型方法的扩展</h2><pre><code>    //公共正则表达式处理函数
    <span class="type">String</span>.prototype.<span class="type">Regular</span> = function(reg){
        <span class="keyword">var</span> <span class="literal">result</span> = <span class="literal">true</span>;
        <span class="keyword">if</span>(this.length &gt; <span class="number">0</span>){       
            <span class="keyword">if</span>(!reg.test(this)){   
                <span class="literal">result</span> = <span class="literal">false</span>;
            }  
        } 
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    //.trim()方法
     <span class="type">String</span>.prototype.trim = function () {
        <span class="keyword">return</span> this.replace(/(^\s*)|(\s*$)/g,'');
};
</code></pre><p><code>^</code>表示字符串必须以后面的规则开头，而<code>(^\s*)</code> 表示的就是以0个空格或者多个空格开头，后面的<code>(\s*$)</code> 的意思就是, 以0个空格或者多个空格结尾。</p>
<pre><code>  <span class="comment">//判断输入内容是否为空</span>
  <span class="built_in">String</span>.prototype.isNull = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{  
      <span class="keyword">return</span> <span class="keyword">this</span>.trim().length == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>; 
  } 

  <span class="comment">//判断输入的字符是否为英文字母\数字\下划线</span>
  <span class="built_in">String</span>.prototype.isVersion = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    
      <span class="keyword">var</span> reg = <span class="regexp">/^([a-zA-Z_])([a-zA-Z0-9_.])*$/</span>;  
      <span class="keyword">return</span> <span class="keyword">this</span>.Regular(reg);
  }

 <span class="comment">// 判断输入的字符串，不包括单引号</span>
 <span class="built_in">String</span>.prototype.isString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    
      <span class="keyword">var</span> reg = <span class="regexp">/^[^']*$/</span>; 
      <span class="keyword">return</span> <span class="keyword">this</span>.Regular(reg); 
  }

<span class="comment">//判断输入的字符是否为英文字母  </span>
  <span class="built_in">String</span>.prototype.isLetter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{   
     <span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z]+$/</span>;  
     <span class="keyword">return</span> <span class="keyword">this</span>.Regular(reg);
 }     
</code></pre><h2 id="constructor属性">constructor属性</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">()</span><span class="comment">{}</span>
<span class="title">var</span> <span class="title">me</span> = <span class="title">new</span> <span class="title">User</span><span class="params">()</span>;</span>
console.log(me.<span class="keyword">constructor</span>);<span class="comment">//[Function: User]</span>

<span class="comment">//用前一个对象的Constructor引用来创建一个新的User对象</span>
<span class="keyword">var</span> you = <span class="keyword">new</span> me.<span class="keyword">constructor</span>();
console.log(me.<span class="keyword">constructor</span> == you.<span class="keyword">constructor</span>);<span class="comment">//true</span>
</code></pre><h2 id="Object-create">Object.create</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>{}
 <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(Parent.prototype);
 <span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> Parent);<span class="comment">//true</span>
 <span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span>
 <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(o));<span class="comment">//[object Object]</span>
</code></pre><p>“数据属性”是可获取且可设置值的属性。 数据属性描述符包含 <code>value</code> 特性，以及 <code>writable、enumerable</code> 和 <code>configurable</code> 特性。 如果未指定最后三个特性，则它们默认为 <code>false</code>。 </p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>{}
<span class="keyword">var</span> o = <span class="built_in">Object</span>.create(Parent);
<span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> Parent);<span class="comment">//false</span>
<span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true  </span>
</code></pre><p>另外一个实例</p>
<pre><code>var book1 = {
    title:<span class="string">"JS高级程序设计"</span>,
    pages : <span class="number">1001</span>,
    getTitle:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.<span class="built_in">log</span><span class="params">(this.title)</span>;
    }
};
var book2 = Object.create<span class="params">(book1,{
    //title会成为所创建对象的数据属性
    title:{
        configurable:<span class="literal">true</span>,
        enumerable:<span class="literal">true</span>,
        value:<span class="string">"JS权威指南"</span>,
        wratable:<span class="literal">true</span>
    }
})</span>;
book1.getTitle<span class="params">()</span>;  <span class="comment">//"JS高级程序设计"</span>
book2.getTitle<span class="params">()</span>;  <span class="comment">//"JS权威指南"</span>

console.<span class="built_in">log</span><span class="params">(book1.hasOwnProperty<span class="params">(<span class="string">"getTitle"</span>)</span>)</span>;  <span class="comment">//true</span>
console.<span class="built_in">log</span><span class="params">('pages' in book2)</span>;  <span class="comment">//true</span>
console.<span class="built_in">log</span><span class="params">(book2.hasOwnProperty<span class="params">(<span class="string">"getTitle"</span>)</span>)</span>;  <span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(book1.isPrototypeOf<span class="params">(book2)</span>)</span>;<span class="comment">//true</span>
</code></pre><p>再看另一个例子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span><span class="params">()</span><span class="comment">{}</span>
<span class="title">obj</span> = <span class="title">new</span> <span class="title">Constructor</span><span class="params">()</span>;</span>
<span class="comment">// 上面的一句就相当于:</span>
obj = <span class="keyword">Object</span>.create(<span class="function"><span class="keyword">Constructor</span>.<span class="title">prototype</span>);</span>
console.log(obj);<span class="comment">//{}</span>
console.log(<span class="keyword">Object</span>.create(<span class="function"><span class="keyword">Constructor</span>.<span class="title">prototype</span>));</span><span class="comment">//{}</span>

console.log(obj instanceof <span class="function"><span class="keyword">Constructor</span>);</span><span class="comment">//true</span>
console.log(<span class="function"><span class="keyword">Constructor</span>.<span class="title">prototype</span>.<span class="title">isPrototypeOf</span><span class="params">(obj)</span>);</span><span class="comment">//true</span>

<span class="keyword">var</span> foo;
foo = <span class="comment">{}</span>;
<span class="comment">// 以字面量方式创建的空对象就相当于:</span>
foo = <span class="keyword">Object</span>.create(<span class="keyword">Object</span>.prototype);
</code></pre><p>另外：</p>
<pre><code><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype);<span class="comment">//{}</span>
<span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype));<span class="comment">//{}</span>
</code></pre><p>通过<code>Object.create(Object.prototype)</code> 创建的实例对象就继承了<code>Object</code>原型下的属性和方法。</p>
<p><code>javascript</code>所有<code>function</code>类型的对象都有一个<code>prototype</code>属性。这个<code>prototype</code>属性本身又是一个<code>object</code>类型的对象，原型对象都包含一个指向构造函数的指针，而每一个实例也都包含一个指向原型对象内部的指针。</p>
<blockquote>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>
</blockquote>
<h2 id="prototype">prototype</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">()</span>{</span>}

var u1 = new User<span class="params">()</span>;
console.<span class="built_in">log</span><span class="params">(u1.prototype)</span>;<span class="comment">//使用对象实例无法访问到prototype</span>
console.<span class="built_in">log</span><span class="params">(User.prototype)</span>;<span class="comment">//{},使用构造函数名访问prototype</span>
console.<span class="built_in">log</span><span class="params">(u1.__proto__)</span>;<span class="comment">//{},使用对象实例访问prototype的指针</span>

<span class="comment">//使用字面量的方式创建原型对象，这里{}就是对象</span>
User.prototype = {
    name : <span class="string">"trigkit4"</span>,
    age : <span class="number">22</span>
};
</code></pre><p>使用<code>构造函数</code>创建原型对象和使用<code>字面量</code>创建对象在使用上基本相同，但还是有些区别，字面量创建的方式使用<code>constructor</code>属性不会指向实例，而会指向<code>Object</code>，构造函数创建的方式则相反</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">()</span>{</span>}
User.prototype = {
    name : <span class="string">"trigkit4"</span>,
    age : <span class="number">22</span>
};
var u1 = new User<span class="params">()</span>;
console.<span class="built_in">log</span><span class="params">(u1.constructor)</span>;<span class="comment">//function Object() {[native code]}</span>
console.<span class="built_in">log</span><span class="params">(u1 instanceof User)</span>;<span class="comment">//true</span>
console.<span class="built_in">log</span><span class="params">(u1.constructor == User)</span>;<span class="comment">//false</span>
console.<span class="built_in">log</span><span class="params">(u1.constructor == Object)</span>;<span class="comment">//true</span>

<span class="comment">//如果想让字面量方式的constructor指向实例对象，可以这么做：</span>
User.prototype = {
    constructor : User;
}
</code></pre><p>字面量方式为什么<code>constructor</code>会指向<code>Object</code>？因为<code>User.prototype = {};</code>这种写法其实就是创建了一个新对象：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">User</span>(</span>){}

User.prototype = {
    constructor : User
};
var u1 = <span class="keyword">new</span> User();
console.<span class="built_in">log</span>(User.constructor);//[<span class="function"><span class="keyword">Function</span>:</span> <span class="function"><span class="keyword">Function</span>]</span>
console.<span class="built_in">log</span>(u1.constructor == User);//<span class="literal">true</span>
</code></pre><p>另一个例子：</p>
<pre><code>(<span class="function"><span class="keyword">function</span></span> () {

       console.<span class="built_in">log</span>(Object.prototype);//{}
       console.<span class="built_in">log</span>(Array.prototype);//[]
       console.<span class="built_in">log</span>(Array.prototype.push);//[<span class="function"><span class="keyword">Function</span></span>: push]
       console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>);//[<span class="function"><span class="keyword">Function</span></span>: Empty]
       console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.<span class="keyword">bind</span>);//[<span class="function"><span class="keyword">Function</span></span>: <span class="keyword">bind</span>]


   })();
</code></pre><h2 id="Object-prototype-toString">Object.prototype.toString</h2><p>在<code>toString()</code>方法被调用时,会执行下面的操作步骤:</p>
<pre><code>如果<span class="keyword">this</span>的值为undefined,则返回<span class="string">"[object Undefined]"</span>.
如果<span class="keyword">this</span>的值为<span class="keyword">null</span>,则返回<span class="string">"[object Null]"</span>.
让O成为调用ToObject(<span class="keyword">this</span>)的结果.
让<span class="keyword">class</span>成为O的内部属性[[<span class="keyword">Class</span>]]的值.
返回三个字符串<span class="string">"[object "</span>, <span class="keyword">class</span>, 以及 <span class="string">"]"</span>连接后的新字符串.
</code></pre><p>由于 <code>JavaScript</code> 中一切都是对象，任何都不例外，对所有值类型应用<code>Object.prototype.toString.call()</code></p>
<p>方法结果如下：</p>
<pre><code>console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">(<span class="number">123</span>)</span>)</span> <span class="comment">//[object Number]        </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">('<span class="number">123</span>')</span>)</span> <span class="comment">//[object String]      </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">(<span class="literal">undef</span>ined)</span>)</span> <span class="comment">//[object Undefined] </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">(<span class="literal">true</span>)</span>)</span> <span class="comment">//[object Boolean]      </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">({})</span>)</span> <span class="comment">//[object Object]        </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">([])</span>)</span> <span class="comment">//[object Array]      </span>
console.<span class="built_in">log</span><span class="params">(Object.prototype.toString.call<span class="params">(function<span class="params">()</span>{})</span>)</span> <span class="comment">//[object Function]</span>
</code></pre><p>​<br>所有类型都会得到不同的字符串，几乎完美。<br>在<code>JavaScript</code>中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过<code>Object.prototype.toString</code>方法.</p>
<h2 id="面向对象">面向对象</h2><p>下面是来自<code>Prototype.js</code>的一段代码：</p>
<pre><code><span class="comment">//创建一个名为"Class"的全局对象</span>
<span class="keyword">var</span> Class = {
    <span class="comment">//它只有一个函数，其作用是创建一个新的对象构造函数</span>
    create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="comment">//创建一个匿名的对象构造函数</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
            <span class="comment">//调用它本身的初始化方法</span>
            <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);
        }
    }
};

<span class="comment">//给Object对象添加一个新的静态方法，它的作用是把属性从一个对象复制到另一个中</span>
<span class="built_in">Object</span>.extend = <span class="function"><span class="keyword">function</span> (<span class="params">destination,source</span>) </span>{
    <span class="comment">//遍历所有要扩展的属性</span>
    <span class="keyword">for</span>(property <span class="keyword">in</span> source){
        <span class="comment">//然后将他们添加到目标对象中</span>
        destination[property] = source[property];
    }
};
</code></pre><h2 id="成员操作符">成员操作符</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">aFunc</span><span class="params">()</span>{</span>}<span class="comment">//或者var aFunc = function(){};</span>

aFunc.oProperty = <span class="string">"函数的一个属性"</span>;
aFunc.aMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"函数的一个方法"</span>)</span>;
};

console.<span class="built_in">log</span><span class="params">(aFunc[<span class="string">"oProperty"</span>])</span>;<span class="comment">//将函数当成数组以属性名作为下标来访问属性</span>
console.<span class="built_in">log</span><span class="params">(aFunc[<span class="string">"aMethod"</span>]<span class="params">()</span>)</span>;<span class="comment">//将函数当数组以方法名作为下标来调用方法</span>

<span class="comment">//遍历函数的所有属性和方法</span>
<span class="keyword">for</span><span class="params">(var s in aFunc)</span>{
    console.<span class="built_in">log</span><span class="params">(s + <span class="string">"is a "</span>+typeof<span class="params">(aFunc[s])</span>)</span>;
}
</code></pre><h2 id="特权方法与私有方法">特权方法与私有方法</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span><span class="params">(msg)</span><span class="comment">{
    this.Message = msg;

    //私有属性
    var separator = '-';
    var owner = this;

    //私有方法
    function alertMessage(){
        console.log(owner.Message);
    }</span>
    <span class="title">alertMessage</span><span class="params">()</span>;</span>

    <span class="comment">//特权方法（也是公有方法）</span>
    this.aptMessage = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> <span class="comment">{
        this.Message += separator + str;
        alertMessage();
    }</span>
}

<span class="comment">//公有方法</span>
<span class="title">Constructor</span>.<span class="title">prototype</span>.<span class="title">clearMessage</span> = <span class="title">function</span> <span class="params">(str)</span> <span class="comment">{
    this.Message = '';
}</span>;</span>

<span class="comment">//静态属性</span>
<span class="function"><span class="keyword">Constructor</span>.<span class="title">name</span> = '<span class="title">trigkit4</span>';</span>

<span class="comment">//静态方法</span>
<span class="function"><span class="keyword">Constructor</span>.<span class="title">alertName</span> = <span class="title">function</span> <span class="params">(name)</span> <span class="comment">{
    console.log(this.name);
}</span>;</span>
</code></pre><p><code>特权方法</code>是指在构造函数的作用域中使用<code>this</code>关键字定义的方法；与私有方法不同，特权方法能够被公开访问，而且还能够访问私有成员。</p>
<blockquote>
<p>由于私有和特权成员在函数的内部，因此它们会被带到函数的每个实例中。<br>公有的原型成员是对象蓝图的一部分，适用于通过<code>new</code>关键字实例化的该对象的每个实例 静态成员只适用于对象的一个特殊实例</p>
</blockquote>
<p>使用对象字面量语法来向<code>prototype</code>属性添加所有公有成员：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span><span class="params">()</span></span>{
    <span class="comment">//私有和特权成员</span>
}

<span class="comment">//公有方法</span>
Constructor.prototype = {
    propertyA: <span class="string">'value1'</span>,
    propertyB: <span class="string">'value2'</span>,
    methodA: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{},
    methodB: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}
};
</code></pre><h2 id="删除不要的节点">删除不要的节点</h2><p><code>DOM</code> 元素在浏览器中所占用的空间是非常大的，要及时回收不用的节点：</p>
<pre><code><span class="variable"><span class="keyword">var</span> node</span> = parentNode.removeChild(node);

node = <span class="literal">null</span>;<span class="comment">//设置为空，释放空间</span>
CollectGarbage();<span class="comment">//IE,回收资源</span>
</code></pre><p>后续更新 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 trigkit4
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>